// Generated by LiveScript 1.2.0
var soc, sinon, sinonChai, chai, expect, _extend, o, x;
soc = require('../lib');
sinon = require('sinon');
sinonChai = require('sinon-chai');
chai = require('chai');
expect = chai.expect;
chai.use(sinonChai);
_extend = require('util')._extend;
o = it;
x = it.skip;
describe('soc', function(){
  describe('#unwrap', function(){
    context('when not given an initial object', function(){
      beforeEach(function(){
        return this.soc = soc();
      });
      return o('returns an empty object', function(){
        return expect(this.soc.unwrap()).to.eql({});
      });
    });
    return context('when given an initial object', function(){
      beforeEach(function(){
        this.initialObject = {
          foo: 'foo'
        };
        return this.soc = soc(this.initialObject);
      });
      return o('returns the initial object', function(){
        return expect(this.soc.unwrap()).to.eql(this.initialObject);
      });
    });
  });
  describe('#merge', function(){
    beforeEach(function(){
      return this.soc = soc();
    });
    context('when extend is not given an object', function(){
      return o('recursively calls soc with the initial object', function(){
        return expect(this.soc.merge().unwrap()).to.eql({});
      });
    });
    return context('when extend is given an object', function(){
      return o('extends the initial object wrapped by soc', function(){
        return expect(this.soc.merge({
          foo: 'foo'
        }).unwrap()).to.eql({
          foo: 'foo'
        });
      });
    });
  });
  return describe('mutability', function(){
    return context('when soc is given an object', function(){
      o('Should return the same reference of initial object', function(){
        var foo;
        foo = {
          foo: 'foo'
        };
        return expect(soc(foo).unwrap()).to.equal(foo);
      });
      return o('Should extend the initial object reference', function(){
        var foo, bar;
        foo = {
          foo: 'foo'
        };
        bar = {
          bar: 'bar'
        };
        return expect(soc(foo).merge(bar).unwrap()).to.equal(_extend(foo, bar));
      });
    });
  });
});